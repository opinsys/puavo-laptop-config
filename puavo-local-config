#!/usr/bin/ruby1.9.1

# puavo-local-config configures system according to admin user preferences.
# See puavo-local-config-ui for the user interface.  puavo-local-config
# reads a configuration file ("/etc/puavo/local.json" by default) that
# contains user preferences, and applies those to the system depending on
# given option arguments.  Run "puavo-local-config --help" for information
# on command arguments.  All wanted functionality must be explicitly requested
# with command arguments.

require 'etc'
require 'fileutils'
require 'getoptlong'
require 'json'

Ltspadmins_group_id = 3000

def print_help()
  puts <<-EOF
puavo-local-config [OPTIONS]

-c, --config-path      set configuration file path
-h, --help             show help

    --admins           configure admins
    --grub-default     configure grub default
    --local-users      configure local users

    --setup-software   ["all" | a list of software separated with comma]
  EOF
end

def search_and_replace_line(file, re, new_line)
  File.open(file, 'r') do |inputf|
    output_lines = []

    have_match = false

    inputf.flock(File::LOCK_EX);

    input_lines = inputf.read.split("\n")
    input_lines.each do |line|
      match = line.match(re)
      if match then
        have_match = true
        output_lines.push(new_line)
      else
        output_lines.push(line)
      end
    end

    if !have_match then
      output_lines.push(new_line)
    end

    output = output_lines.map { |s| "#{ s }\n" }.join

    tmpfile = "#{ file }.plctmp"
    File.open(tmpfile, 'w', 0600) { |outputf| outputf.write(output) }
    FileUtils.chmod(inputf.stat.mode, tmpfile)
    FileUtils.chown(inputf.stat.uid, inputf.stat.gid, tmpfile)
    File.rename(tmpfile, file)
  end
end

def configure_admins(conf)
  raise 'No configuration' if conf.nil?

  kernel_cmdline = IO.read('/proc/cmdline')

  # we could also use a new, specific group for this?
  new_line = "puavolocaladmins:x:#{ Ltspadmins_group_id }:#{ conf['admins'].join(',') }"
  search_and_replace_line('/etc/group',
                         /^puavolocaladmins:/,
                         new_line)

  File.open('/etc/sudoers.d/puavolocaladmins.pcltmp', 'w') do |f|
    if superlaptop_mode? then
      f.write("%puavolocaladmins ALL=(ALL) ALL\n")
    end
  end
  File.rename('/etc/sudoers.d/puavolocaladmins.pcltmp',
              '/etc/sudoers.d/puavolocaladmins')
end

def configure_local_users(conf)
  raise 'No configuration' if conf.nil?

  uid     = 3001
  uid_max = 3999

  conf['local_users'].each do |user|
    raise 'uid is over uid_max' if uid > uid_max

    home = "/home/#{ uid }"
    group_id = Etc.getgrnam('users').gid
    passwd_line \
      = "#{ user['login'] }:x:#{ uid }:#{ group_id }:#{ user['name'] },,," \
        + ":#{ home }:/bin/bash"
    search_and_replace_line('/etc/passwd',
			    /^#{ user['login'] }:/,
			    passwd_line)

    shadow_line = "#{ user['login'] }:#{ user['hashed_password'] }:::::::"
    search_and_replace_line('/etc/shadow',
                            /^#{ user['login'] }:/,
                            shadow_line)

    FileUtils.mkdir_p(home, :mode => 0700)
    FileUtils.chown(uid, group_id, home)

    uid += 1
  end
end

def configure_grub_default()
  kernel_cmdline = IO.read('/proc/cmdline')
  match = kernel_cmdline.match(/loop=(.*?)\.img/)
  raise 'Could not figure out loop= device' unless match
  loop_img = "#{ match[1] }.img"

  this_ltspimage_name = IO.read('/etc/ltsp/this_ltspimage_name').chomp

  choice_types = {
    '/ltsp.img'        => 'DEFAULT',
    '/ltsp-backup.img' => 'BACKUP',
  }

  choice_type = choice_types[loop_img]
  description \
    = choice_type \
        ? "#{ choice_type } - (lvm/puavo-images)/#{ this_ltspimage_name } (#{ loop_img })" \
        : "OTHER (#{ loop_img })"

  if superlaptop_mode?
    description = "*SUPERLAPTOP* #{ description }"
  end

  system('grub-editenv',
         '/images/boot/grub/grubenv',
         'set',
         %Q{default=#{ description }}) \
    or raise 'Problem in updating grub environment'
end

def superlaptop_mode?
  kernel_cmdline = IO.read('/proc/cmdline')
  superlaptop_mode_re \
    = /puavo.image.overlay=default puavo.local.enable_superusers=true/
  kernel_cmdline.match(superlaptop_mode_re) ? true : false
end

def setup_software(conf, software_list)
  if software_list.include?('all')
    software_list \
      = Dir.glob('/usr/share/puavo-ltsp-client/restricted-packages/*') \
           .map { |s| File.basename(s) }
  end

  to_install, to_uninstall \
    = software_list.partition { |software| conf['licenses'][software] }

  if !to_install.empty? then
    system('puavo-restricted-package-tool', 'install', *to_install) \
      or warn 'Problem in installing packages'
  end

  if !to_uninstall.empty? then
    system('puavo-restricted-package-tool', 'uninstall', *to_uninstall) \
      or warn 'Problem in uninstalling packages'
  end
end

config_path = '/state/etc/puavo/local/config.json'

# we prepare the standard config path directory
config_path_dir = File.dirname(config_path)
FileUtils.mkdir_p(config_path_dir)
FileUtils.chmod(02770, config_path_dir)
FileUtils.chown(0, Ltspadmins_group_id, config_path_dir)

apply_configs = []
software_list = []

begin
  opts = GetoptLong.new(
    [ '--config-path',       '-c', GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--help',              '-h', GetoptLong::NO_ARGUMENT,       ],

    [ '--admins',                  GetoptLong::NO_ARGUMENT,       ],
    [ '--grub-default',            GetoptLong::NO_ARGUMENT,       ],
    [ '--local-users',             GetoptLong::NO_ARGUMENT,       ],
    [ '--setup-software',          GetoptLong::REQUIRED_ARGUMENT, ],
  )

  opts.each do |opt, arg|
    case opt
      when '--config-path'
	config_path = arg
      when '--help'
	print_help()
	exit(0)
      when '--admins', '--grub-default', '--local-users'
	apply_configs.push(opt)
      when '--setup-software'
	apply_configs.push(opt)
	software_list = arg.split(',')
    end
  end

rescue GetoptLong::InvalidOption => e
  print_help()
  exit(1)
end

begin
  conf = JSON.parse( IO.read(config_path) )
rescue Exception => e
  warn "Could not read and interpret #{ config_path }: #{ e.message }"
  conf = nil
end

dispatch_table = {
  '--admins'         => lambda { configure_admins(conf)              },
  '--grub-default'   => lambda { configure_grub_default()            },
  '--local-users'    => lambda { configure_local_users(conf)         },
  '--setup-software' => lambda { setup_software(conf, software_list) },
}

exit_code = 0

apply_configs.each do |part|
  begin
    dispatch_table[part].call()
  rescue Exception => e
    warn "Could not handle #{ part }: #{ e.message } / #{ e.backtrace }"
    exit_code = 1
  end
end

exit(exit_code)
