#!/usr/bin/ruby1.9.1

# puavo-local-config configures system according to admin user preferences.
# See puavo-local-config-ui for the user interface.  puavo-local-config
# reads a configuration file ("/state/etc/puavo/local/config.json"
# by default) that contains user preferences, and applies those to the
# system depending on given option arguments.  Run
# "puavo-local-config --help" for information on command arguments.
# Most wanted functionality must be explicitly requested with command
# arguments, but puavo-local-config also intends to prepare the system for
# configuration (by puavo-local-config-ui).

require 'etc'
require 'fileutils'
require 'getoptlong'
require 'json'

Ltspadmins_group_id = 3000

def print_help()
  puts <<-EOF
puavo-local-config [OPTIONS]

-c, --config-path     set configuration file path
-h, --help            show help

    --admins          configure admins
    --grub-default    configure grub default
    --local-users     configure local users

    --download-pkgs   ["all" | a list of software separated with comma]
    --setup-pkgs      ["all" | a list of software separated with comma]
  EOF
end

def conf_version_1_ok?(conf)
  is_boolean = lambda { |v| v.kind_of?(TrueClass) || v.kind_of?(FalseClass) }

  conf['admins'].kind_of?(Array) \
    && conf['admins'].map { |s| s.kind_of?(String) } \
    && conf['allow_logins_for'].kind_of?(Array) \
    && conf['allow_logins_for'].map { |s| s.kind_of?(String) }.all? \
    && is_boolean.call(conf['allow_remoteadmins']) \
    && conf['licenses'].kind_of?(Hash) \
    && conf['licenses'].map do |k, v|
                              k.kind_of?(String) && is_boolean.call(v)
                            end \
                       .all? \
    && conf['local_users'].kind_of?(Array) \
    && conf['local_users'].map do |u|
                                 u.kind_of?(Hash) \
                                   && u['hashed_password'].kind_of?(String) \
                                   && u['login'].kind_of?(String)           \
                                   && u['name'].kind_of?(String)
                               end \
                          .all?
end

def ensure_conf_sanity(conf, config_path)
  move_conf = lambda {
                warn 'Moving configuration file, because it is messed up'
                FileUtils.mv(config_path,
                             "#{ config_path }.backup-#{ Time.now().to_i }")
              }

  if conf.nil? then
    if File.exists?(config_path) then
      move_conf.call()
    end
    return nil
  end

  # this might include migration code if version should be greater

  if conf['version'] == 1 && conf_version_1_ok?(conf) then
    return conf
  else
    move_conf.call()
    return nil
  end
end

def search_and_replace_line(file, re, new_line)
  File.open(file, 'r') do |inputf|
    output_lines = []

    have_match = false

    inputf.flock(File::LOCK_EX);

    input_lines = inputf.read.split("\n")
    input_lines.each do |line|
      match = line.match(re)
      if match then
        have_match = true
        output_lines.push(new_line)
      else
        output_lines.push(line)
      end
    end

    if !have_match then
      output_lines.push(new_line)
    end

    output = output_lines.map { |s| "#{ s }\n" }.join

    tmpfile = "#{ file }.plctmp"
    File.open(tmpfile, 'w', 0600) { |outputf| outputf.write(output) }
    FileUtils.chmod(inputf.stat.mode, tmpfile)
    FileUtils.chown(inputf.stat.uid, inputf.stat.gid, tmpfile)
    File.rename(tmpfile, file)
  end
end

def configure_admins(conf)
  # If there is no conf, there are no admin, but as a side effect this creates
  # the "puavolocaladmins"-group, which is needed to configure the system
  # (to create the configuration file).  At this stage guest-users will be
  # put into "puavolocaladmins"-group dynamically.
  admins = conf ? conf['admins'] : []

  kernel_cmdline = IO.read('/proc/cmdline')

  # we could also use a new, specific group for this?
  new_line = "puavolocaladmins:x:#{ Ltspadmins_group_id }:#{ admins.join(',') }"
  search_and_replace_line('/etc/group',
                         /^puavolocaladmins:/,
                         new_line)

  File.open('/etc/sudoers.d/puavolocaladmins.pcltmp', 'w') do |f|
    if superlaptop_mode? then
      f.write("%puavolocaladmins ALL=(ALL) ALL\n")
    end
    f.write('%puavolocaladmins ALL=(ALL) NOPASSWD: ' \
            + "/usr/sbin/puavo-local-config\n")
  end
  File.rename('/etc/sudoers.d/puavolocaladmins.pcltmp',
              '/etc/sudoers.d/puavolocaladmins')
end

def configure_local_users(conf)
  return if conf.nil?

  uid_min, uid_max = 3001, 3999
  uid = uid_min

  # XXX should lookup all users between uid_min and uid_max and remove
  # XXX those from /etc/passwd and /etc/shadow, as new ones are added and
  # XXX changes are made.

  conf['local_users'].each do |user|
    raise 'uid is over uid_max' if uid > uid_max

    home = "/home/#{ uid }"
    group_id = Etc.getgrnam('users').gid
    passwd_line \
      = "#{ user['login'] }:x:#{ uid }:#{ group_id }:#{ user['name'] },,," \
        + ":#{ home }:/bin/bash"
    search_and_replace_line('/etc/passwd',
			    /^#{ user['login'] }:/,
			    passwd_line)

    shadow_line = "#{ user['login'] }:#{ user['hashed_password'] }:::::::"
    search_and_replace_line('/etc/shadow',
                            /^#{ user['login'] }:/,
                            shadow_line)

    uid += 1
  end
end

def configure_grub_default()
  kernel_cmdline = IO.read('/proc/cmdline')
  match = kernel_cmdline.match(/loop=(.*?)\.img/)
  raise 'Could not figure out loop= device' unless match
  loop_img = "#{ match[1] }.img"

  this_ltspimage_name = IO.read('/etc/ltsp/this_ltspimage_name').chomp

  choice_types = {
    '/ltsp.img'        => 'DEFAULT',
    '/ltsp-backup.img' => 'BACKUP',
  }

  choice_type = choice_types[loop_img]
  description \
    = choice_type \
        ? "#{ choice_type } - (lvm/puavo-images)/#{ this_ltspimage_name } (#{ loop_img })" \
        : "OTHER (#{ loop_img })"

  if superlaptop_mode?
    description = "*SUPERLAPTOP* #{ description }"
  end

  system('/usr/bin/grub-editenv',
         '/images/boot/grub/grubenv',
         'set',
         %Q{default=#{ description }}) \
    or raise 'Problem in updating grub environment'
end

def download_pkgs(pkg_list)
  restricted_package_tool('download', *pkg_list) \
    or raise "Problem in downloading: #{ pkg_list.join(', ') }"
end

def parse_pkg_list(pkg_list)
  pkg_list == 'all' \
    ? Dir.glob('/usr/share/puavo-ltsp-client/restricted-packages/*') \
         .map { |s| File.basename(s) } \
    : pkg_list.split(',')
end

def restricted_package_tool(*args)
  system('/usr/sbin/puavo-restricted-package-tool', *args)
end

def setup_pkgs(conf, pkg_list)
  return if conf.nil?

  to_install, to_uninstall = pkg_list.partition { |pkg| conf['licenses'][pkg] }

  if !to_install.empty? then
    restricted_package_tool('install', *to_install) \
      or raise 'Problem in installing packages'
  end

  if !to_uninstall.empty? then
    restricted_package_tool('uninstall', *to_uninstall) \
      or raise 'Problem in uninstalling packages'
  end
end

def superlaptop_mode?
  kernel_cmdline = IO.read('/proc/cmdline')
  superlaptop_mode_re \
    = /puavo.image.overlay=default puavo.local.enable_superusers=true/
  kernel_cmdline.match(superlaptop_mode_re) ? true : false
end

config_path = '/state/etc/puavo/local/config.json'

apply_configs     = []
download_pkg_list = []
setup_pkg_list    = []

begin
  opts = GetoptLong.new(
    [ '--config-path',   '-c', GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--help',          '-h', GetoptLong::NO_ARGUMENT,       ],

    [ '--admins',              GetoptLong::NO_ARGUMENT,       ],
    [ '--grub-default',        GetoptLong::NO_ARGUMENT,       ],
    [ '--local-users',         GetoptLong::NO_ARGUMENT,       ],
    [ '--download-pkgs',       GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--setup-pkgs',          GetoptLong::REQUIRED_ARGUMENT, ],
  )

  opts.each do |opt, arg|
    case opt
      when '--config-path'
	config_path = arg
      when '--help'
	print_help()
	exit(0)
      when '--admins', '--grub-default', '--local-users'
	apply_configs.push(opt)
      when '--download-pkgs'
	apply_configs.push(opt)
	download_pkg_list = parse_pkg_list(arg)
      when '--setup-pkgs'
	apply_configs.push(opt)
	setup_pkg_list = parse_pkg_list(arg)
    end
  end

rescue GetoptLong::InvalidOption => e
  print_help()
  exit(1)
end

# we prepare the standard config path directory
config_path_dir = File.dirname(config_path)
FileUtils.mkdir_p(config_path_dir)
FileUtils.chmod(02770, config_path_dir)
FileUtils.chown(0, Ltspadmins_group_id, config_path_dir)

begin
  conf = JSON.parse( IO.read(config_path) )
rescue Errno::ENOENT
  conf = nil
  # configure puavo-local-config-ui to autostart if configuration is missing
  FileUtils.cp('/usr/share/applications/puavo-local-config-ui.desktop',
	       '/etc/xdg/autostart/puavo-local-config-ui.desktop')
rescue Exception => e
  warn "Could not read and interpret #{ config_path }: #{ e.message }"
  conf = nil
end

conf = ensure_conf_sanity(conf, config_path)

dispatch_table = {
  '--admins'        => lambda { configure_admins(conf)           },
  '--grub-default'  => lambda { configure_grub_default()         },
  '--local-users'   => lambda { configure_local_users(conf)      },
  '--download-pkgs' => lambda { download_pkgs(download_pkg_list) },
  '--setup-pkgs'    => lambda { setup_pkgs(conf, setup_pkg_list) },
}

exit_code = 0

apply_configs.each do |part|
  begin
    dispatch_table[part].call()
  rescue Exception => e
    warn "Could not handle #{ part }: #{ e.message } / #{ e.backtrace }"
    exit_code = 1
  end
end

exit(exit_code)
