#!/usr/bin/ruby1.9.1
# encoding: UTF-8

# puavo-local-config configures system according to admin user preferences.
# See puavo-local-config-ui for the user interface.  puavo-local-config
# reads a configuration file ("/state/etc/puavo/local/config.json"
# by default) that contains user preferences, and applies those to the
# system depending on given option arguments.  Run
# "puavo-local-config --help" for information on command arguments.
# Most wanted functionality must be explicitly requested with command
# arguments, but puavo-local-config also intends to prepare the system for
# configuration (by puavo-local-config-ui).

require 'etc'
require 'fileutils'
require 'getoptlong'
require 'json'
require 'syslog'

Ltspadmins_group_id = 3000

def print_help()
  puts <<-EOF
puavo-local-config [OPTIONS]

-c, --config-path           set configuration file path
-h, --help                  show help

    --admins                configure admins
    --grub-default          configure grub default
    --local-users           configure local users
    --networkmanager-policy apply special networkmanager permissions
    --prepare-puavopkg      setup configurations for puavo-pkg
    --setup-installed-pkgs  configure installed (optional) packages

    --install-pkg           a package name
    --remove-pkg            ["--all" | a package name]

  --install-pkg and --remove-pkg can be specified multiple times.
  EOF
end

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end

def conf_version_1_ok?(conf)
  is_boolean = lambda { |v| v.kind_of?(TrueClass) || v.kind_of?(FalseClass) }

  conf['allow_logins_for'].kind_of?(Array) \
    && conf['allow_logins_for'].map { |s| s.kind_of?(String) }.all? \
    && is_boolean.call(conf['allow_remoteadmins']) \
    && conf['local_users'].kind_of?(Hash) \
    && conf['local_users'].map do |login, u|
                                 login.kind_of?(String) \
                                   && u.kind_of?(Hash) \
                                   && u['hashed_password'].kind_of?(String) \
                                   && u['name'].kind_of?(String) \
                                   && u['uid'].kind_of?(Integer) \
                                   && is_boolean.call(u['enabled'])
                               end \
                          .all?
end

def ensure_conf_sanity(conf, config_path)
  move_conf = lambda {
                logerr(Syslog::LOG_CRIT,
                      "Moving configuration file, because it is messed up\n")
                FileUtils.mv(config_path,
                             "#{ config_path }.backup-#{ Time.now().to_i }")
              }

  if conf.nil? then
    if File.exists?(config_path) then
      move_conf.call()
    end
    return nil
  end

  # this might include migration code if version should be greater

  unless conf['version'] == 1 && conf_version_1_ok?(conf) then
    move_conf.call()
    return nil
  end

  # all is OK!

  conf
end

$primary_user = nil
def get_primary_user()
  return $primary_user if $primary_user

  begin
    device = JSON.parse( IO.read('/state/etc/puavo/device.json') )
    primary_user = device.kind_of?(Hash) && device['primary_user']

    if primary_user && primary_user.match(/^[A-Za-z0-9\.\-]+$/) then
      $primary_user = primary_user
    else
      raise 'Primary user is not set or is in invalid format'
    end
  rescue StandardError => e
    logerr(Syslog::LOG_WARNING, "Could not find primary user: %s\n", e.message)
    return nil
  end

  $primary_user
end

def search_and_replace_line(file, re, new_line)
  File.open(file, 'r') do |inputf|
    output_lines = []

    have_match = false

    inputf.flock(File::LOCK_EX);

    input_lines = inputf.read.split("\n")
    input_lines.each do |line|
      match = line.match(re)
      if match then
        have_match = true
        output_lines.push(new_line) if new_line
      else
        output_lines.push(line)
      end
    end

    if !have_match then
      output_lines.push(new_line) if new_line
    end

    output = output_lines.map { |s| "#{ s }\n" }.join

    tmpfile = "#{ file }.plctmp"
    File.open(tmpfile, 'w', 0600) { |outputf| outputf.write(output) }
    FileUtils.chmod(inputf.stat.mode, tmpfile)
    FileUtils.chown(inputf.stat.uid, inputf.stat.gid, tmpfile)
    File.rename(tmpfile, file)
  end
end

def configure_admins()
  log(Syslog::LOG_INFO, "configuring admins\n")

  admin = get_primary_user() || ''

  kernel_cmdline = IO.read('/proc/cmdline')

  new_line = "puavolocaladmins:x:#{ Ltspadmins_group_id }:#{ admin }"
  search_and_replace_line('/etc/group',
                         /^puavolocaladmins:/,
                         new_line)

  search_and_replace_line('/etc/gshadow',
                         /^puavolocaladmins:/,
                         "puavolocaladmins:!::#{ admin }")

  File.open('/etc/sudoers.d/puavolocaladmins.pcltmp', 'w') do |f|
    if superlaptop_mode? then
      f.write("%puavolocaladmins ALL=(ALL) ALL\n")
    end
    f.write('%puavolocaladmins ALL=(ALL) NOPASSWD: ' \
            + "/usr/sbin/puavo-local-config, /usr/sbin/getweb\n")
  end
  File.rename('/etc/sudoers.d/puavolocaladmins.pcltmp',
              '/etc/sudoers.d/puavolocaladmins')
end

def configure_local_users(conf)
  return if conf.nil?

  log(Syslog::LOG_INFO, "configuring local users\n")

  primary_user = get_primary_user()

  uid_min, uid_max = 3001, 3999
  group_id = Etc.getgrnam('users').gid

  problems = false

  conf['local_users'].each do |login, user|
    if user['uid'] < uid_min then
      logerr(Syslog::LOG_WARNING, "uid is below uid_min for %s\n", login)
      problems = true
      next
    end
    if user['uid'] > uid_max
      logerr(Syslog::LOG_WARNING, "uid is over uid_max for %s\n", login)
      problems = true
      next
    end

    if primary_user == login then
      logerr(Syslog::LOG_WARNING,
             "disabling login that is reserved for primary user: %s\n",
             login)
      user['enabled'] = false
    end

    home = "/home/#{ login }"
    passwd_line \
      = user['enabled'] \
          ? ("#{ login }:x:#{ user['uid'] }:#{ group_id }" \
               + ":#{ user['name'] },,,:#{ home }:/bin/bash")
          : nil

    search_and_replace_line('/etc/passwd',
			    /^#{ login }:/,
			    passwd_line)

    shadow_line = user['enabled'] \
                    ? "#{ login }:#{ user['hashed_password'] }:::::::" \
                    : nil

    search_and_replace_line('/etc/shadow',
                            /^#{ login }:/,
                            shadow_line)
  end

  raise 'Problems in configure_local_users' if problems
end

def configure_grub_default()
  log(Syslog::LOG_INFO, "configuring grub default\n")

  kernel_cmdline = IO.read('/proc/cmdline')

  if kernel_cmdline.match(%r{root=/dev/nbd}) then
    log(Syslog::LOG_INFO, "booted from nbd, nothing to do\n")
    return
  end

  match = kernel_cmdline.match(/loop=(.*?)\.img/)
  raise 'Could not figure out loop= device' unless match
  loop_img = "#{ match[1] }.img"

  this_ltspimage_name = IO.read('/etc/ltsp/this_ltspimage_name').chomp

  # XXX need localizations for these
  messages = {
    '/ltsp.img' => { false => 'Normaali käynnistys',
                     true  => 'Kehittäjätila' },
    '/ltsp-backup.img' => { false => 'Varajärjestelmä, normaali käynnistys',
                            true  => 'Varajärjestelmä, kehittäjätila' },
    nil => { false => 'Muu järjestelmä, normaali käynnistys',
             true  => 'Muu järjestelmä, kehittäjätila' },
  }

  msg \
    = messages[loop_img] \
        ? messages[loop_img][superlaptop_mode?] \
        : messages[nil][superlaptop_mode?]

  description \
    = "#{ msg } - (lvm/puavo-images)/#{ this_ltspimage_name } (#{ loop_img })"

  system('/usr/bin/grub-editenv',
         '/images/boot/grub/grubenv',
         'set',
         %Q{default=#{ description }}) \
    or raise 'Problem in updating grub environment'
end

def configure_nm_policy()
  log(Syslog::LOG_INFO, "configuring network manager policy\n")

  admin = get_primary_user()

  confpath = '/etc/polkit-1/localauthority/50-local.d/10.org.freedesktop.networkmanager.allow_modify_by_primary_user.pkla'

  if admin then
    conf = <<EOF
[Primary user permissions]
Identity=unix-user:#{ admin }
Action=org.freedesktop.NetworkManager.settings.modify.system
ResultAny=no
ResultInactive=no
ResultActive=yes
EOF
    File.open(confpath, 'w') { |f| f.print conf }
  else
    FileUtils.rm_f(confpath)
  end
end

def reset_allow_remoteadmins(conf, config_path)
  return conf if (conf.nil? || conf['allow_remoteadmins'] == false)

  log(Syslog::LOG_NOTICE, "remoteadmins were allowed in, disallowing\n")

  # if allow_remoteadmins were set to true, set it false

  conf['allow_remoteadmins'] = false
  tmpfile = "#{ config_path }.tmp"
  File.open(tmpfile, 'w') { |f| f.write(conf.to_json) }
  FileUtils.mv(tmpfile, config_path)

  conf
end

def superlaptop_mode?
  kernel_cmdline = IO.read('/proc/cmdline')
  superlaptop_mode_re \
    = /puavo.image.overlay=default puavo.local.enable_superusers=true/
  kernel_cmdline.match(superlaptop_mode_re) ? true : false
end

#
# puavo-pkg related functions
#

def prepare_puavopkg()
  log(Syslog::LOG_INFO, "preparing puavo-pkg\n")

  %w(/images/puavo-pkg/cache
     /images/puavo-pkg/installers
     /images/puavo-pkg/root).each { |dir| FileUtils.mkdir_p(dir) }

  File.open('/etc/puavo-pkg/puavo-pkg.conf', 'w') do |f|
    f.print(<<'EOF')
### This file is sourced by puavo-pkg Bash script. It must not contain
### anything else than the variable definitions described below.

### Uncomment to change the default cache directory.
PUAVO_PKG_CACHEDIR=/images/puavo-pkg/cache

### Uncomment to change the default root directory for the package tree.
PUAVO_PKG_ROOTDIR=/images/puavo-pkg/root
EOF
  end

  File.open('/etc/puavo-pkg/puavo-pkg-updater.conf', 'w') do |f|
    f.print(<<'EOF')
{
  "installers_dir": "/images/puavo-pkg/installers"
}
EOF
  end
end

def puavo_pkg(*args)
  system('/usr/sbin/puavo-pkg', *args)
end

def install_pkgs(packages)
  packages.each do |pkg|
    re = %r{\A[A-Za-z0-9\-]+\z}
    raise "Package name '#{ pkg }' does not match regexp #{ re }" \
      unless pkg.match(re)

    pkgpath = "/images/puavo-pkg/installers/#{ pkg }.tar.gz"
    puavo_pkg('install', pkgpath) \
      or raise "Problem in installing: #{ pkgpath }"
  end
end

def remove_pkgs(packages)
  packages.each do |pkg|
    puavo_pkg('remove', pkg) \
      or raise "Problem in removing: #{ pkg }"
  end
end

def setup_installed_pkgs()
  puavo_pkg('reconfigure', '--all') \
    or raise 'Problem in reconfiguring packages'
end


Syslog.open(File.basename($0), Syslog::LOG_CONS)

config_path = '/state/etc/puavo/local/config.json'

apply_configs        = []
disable_remoteadmins = false
packages_to_install  = []
packages_to_remove   = []

begin
  opts = GetoptLong.new(
    [ '--config-path',   '-c',   GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--help',          '-h',   GetoptLong::NO_ARGUMENT,       ],

    [ '--admins',                GetoptLong::NO_ARGUMENT,       ],
    [ '--disable-remoteadmins',  GetoptLong::NO_ARGUMENT,       ],
    [ '--grub-default',          GetoptLong::NO_ARGUMENT,       ],
    [ '--install-pkg',           GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--local-users',           GetoptLong::NO_ARGUMENT,       ],
    [ '--networkmanager-policy', GetoptLong::NO_ARGUMENT,       ],
    [ '--remove-pkg',            GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--prepare-puavopkg',      GetoptLong::NO_ARGUMENT,       ],
    [ '--setup-installed-pkgs',  GetoptLong::NO_ARGUMENT,       ],
  )

  opts.each do |opt, arg|
    case opt
      when '--config-path'
	config_path = arg
      when '--disable-remoteadmins'
        disable_remoteadmins = true
      when '--help'
	print_help()
	exit(0)
      when '--admins', '--grub-default', '--local-users'
	apply_configs.push(opt) unless apply_configs.include?(opt)
      when '--install-pkg'
	apply_configs.push(opt) unless apply_configs.include?(opt)
	packages_to_install << arg
      when '--networkmanager-policy'
	apply_configs.push(opt) unless apply_configs.include?(opt)
      when '--prepare-puavopkg'
	apply_configs.push(opt) unless apply_configs.include?(opt)
      when '--remove-pkg'
	apply_configs.push(opt) unless apply_configs.include?(opt)
	packages_to_remove << arg
      when '--setup-installed-pkgs'
	apply_configs.push(opt) unless apply_configs.include?(opt)
    end
  end

rescue GetoptLong::InvalidOption => e
  print_help()
  exit(1)
end

# we prepare the standard config path directory
config_path_dir = File.dirname(config_path)
FileUtils.mkdir_p(config_path_dir)
FileUtils.chmod(02770, config_path_dir)
FileUtils.chown(0, Ltspadmins_group_id, config_path_dir)

begin
  conf = JSON.parse( IO.read(config_path) )
rescue Errno::ENOENT
  conf = nil
rescue Exception => e
  logerr(Syslog::LOG_ERR,
         "Could not read and interpret %s: %s\n",
         config_path,
         e.message)
  conf = nil
end

conf = ensure_conf_sanity(conf, config_path)

if disable_remoteadmins then
  conf = reset_allow_remoteadmins(conf, config_path)
end

dispatch_table = {
  '--admins'                => lambda { configure_admins()                 },
  '--grub-default'          => lambda { configure_grub_default()           },
  '--install-pkg'           => lambda { install_pkgs(packages_to_install)  },
  '--local-users'           => lambda { configure_local_users(conf)        },
  '--networkmanager-policy' => lambda { configure_nm_policy()              },
  '--prepare-puavopkg'      => lambda { prepare_puavopkg()                 },
  '--remove-pkg'            => lambda { remove_pkgs(packages_to_remove)    },
  '--setup-installed-pkgs'  => lambda { setup_installed_pkgs()             },
}

exit_code = 0

if apply_configs.empty? then
  print_help()
  exit(1)
end

apply_configs.each do |part|
  begin
    dispatch_table[part].call()
  rescue Exception => e
    logerr(Syslog::LOG_ERR,
           "%s\n",
           "Could not handle #{ part }: #{ e.message } / #{ e.backtrace }")
    exit_code = 1
  end
end

Syslog.close()

exit(exit_code)
